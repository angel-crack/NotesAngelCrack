[+] Generamos el componente de history:

```powershell
08:54:04 ng g c modules/history/components/Search

CREATE src/app/modules/history/components/search/search.component.html (21 bytes)

CREATE src/app/modules/history/components/search/search.component.spec.ts (559 bytes)

CREATE src/app/modules/history/components/search/search.component.ts (202 bytes)

CREATE src/app/modules/history/components/search/search.component.css (0 bytes)

UPDATE src/app/modules/history/history.module.ts (495 bytes)
```

[+] Vamos a realizar los siguientes cambios:

```powershell
history/
â”£ components/
â”ƒ â”— search/
â”ƒ â”£ search.component.css
```

```css
.search-component {
	padding: 0 1.5rem;
}

.search-component input {
Â  Â  border: 0;
Â  Â  border-radius: 3rem;
Â  Â  height: 40px;
Â  Â  width: 20rem;
Â  Â  padding: 0 .75rem;
Â  Â  font-size: 90%;
}
```

```powershell
â”ƒ â”£ search.component.html
```

```html
<div class="search-component">
Â  Â  <input type="text" placeholder="Artistas, canciones o pÃ³dcast">
Â  Â  <br>
Â  Â  <div>Resultado: </div>
</div>
```

```powershell
â”ƒ â”£ search.component.spec.ts
â”ƒ â”— search.component.ts
â”£ pages/
â”ƒ â”— history-page/
â”ƒ â”£ history-page.component.css
```
```css
.history-page {
Â  Â  padding: .65rem 0;
}
```

```powershell
â”ƒ â”£ history-page.component.html
```

```html
<div class="history-page">
Â  Â  <app-search></app-search>
Â  Â  <app-play-list-body></app-play-list-body>
</div>
```

```powershell
â”ƒ â”£ history-page.component.spec.ts
â”ƒ â”— history-page.component.ts
â”£ history-routing.module.ts
â”— history.module.ts â‡’ Importamos el SharedModule
```

========================

[+] Aplicamos un NgModel, es un comoponente que sirve para relacionar data de manera bidireccional entre el HTML y el TS.

Primero importamos el formModule en el modulo mas cercano:

```ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HistoryRoutingModule } from './history-routing.module';
import { HistoryPageComponent } from './pages/history-page/history-page.component';
import { SearchComponent } from './components/search/search.component';
import { SharedModule } from '@shared/shared.module';
import { FormsModule } from '@angular/forms';

@NgModule({
Â  declarations: [
Â  Â  HistoryPageComponent,
Â  Â  SearchComponent
Â  ],
Â  imports: [
Â  Â  CommonModule,
Â  Â  HistoryRoutingModule,
Â  Â  SharedModule,
Â  Â  FormsModule â‡’ Here!
Â  ]
})
export class HistoryModule { }
```

Ahora ponemos un BananaBox â‡’ [(ngModel)]='src' donde src debe ser creado en el TS

history/
â”£ components/
â”ƒ â”— search/
â”ƒ â”£ search.component.html

```html
<div class="search-component">
Â  Â  <input [(ngModel)]="src" type="text" placeholder="Artistas, canciones o pÃ³dcast">
Â  Â  <br>
Â  Â  <div>Resultado: {{src}} </div>
</div>
```

y en el TS:

```ts
export _class_ SearchComponent {
Â  src:_string_ = ''
}
```

![[search.png]]

Cuando cambiamos en el TS instantaneamente cambiarÃ¡.

[+] AÃ±adimos un evento que detecta cuando hay un cambio en el ngModel â‡’ ngModelChange y enseguida podemos llamar una funcion a la que le pasamos el evento:

[+] Para poder capturar el evento del cambio de esa variable utilizaremos una funcion NgModelChange y le pasaremos el evento, este evento va a contener el valor:

```html
<input (ngModelChange)="callSearch($event)" [(ngModel)]="src" type="text" placeholder="Artistas, canciones o pÃ³dcast"> 
```

Y declaramos la funcion en el TS

```ts
Â  callSearch(_term_: _string_):_void_ {
Â  Â  console.log(term)
Â  }
```

[+] En [[26. @Output]]  Hicimos la siguiente conexion

![[child.png]]

[+] Ahora quisieramos que el padre con la informacion obtenida en el search haga la peticion a la API y esa info se la pase al playlist componente

![[search-service.png]]

[+] Primero vamos a considerar los tracks en el playlist body como un input

```ts
export class PlayListBodyComponent implements OnInit, OnDestroy {
Â  @Input() tracks: _Array_<TrackModel> = []
```

[+] De esta manera vamos a poder pasarlos en HTML del padre

```html
<app-play-list-body [tracks]="[]"></app-play-list-body>
```

[+] Generamos un servicio en el history page que se va a encargar de solicitar la peticion a la API:

```powershell
14:42:48 => ng g s modules/history/services/Search
CREATE src/app/modules/history/services/search.service.spec.ts (357 bytes)
CREATE src/app/modules/history/services/search.service.ts (135 bytes)
```

```ts
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, map } from 'rxjs';
import { environment } from 'src/environments/environment.development';
@Injectable({
Â  providedIn: 'root'
})
export class SearchService {
Â  private readonly URL = environment.api â‡’ Importamos la URL del ENV
Â  constructor(private http:HttpClient) { } â‡’ Inyectamos el servicio de API
  
  searchTracks$(_term_: string): Observable<any> {
Â  Â  return this.http.get(`${this.URL}/tracks?src=${term}`)
Â  Â  Â  .pipe(
Â  Â  Â  Â  map((dataRaw: any) => dataRaw.data)
Â  Â  Â  )
Â  }
}
```

- Creamos una funcion que va a recibir el termino desde el history que recibimos del search
- Hace la peticion y mapea la data

En El History Page hacemos lo siguiente

```ts
Â  listResults$: Observable<any> = of([])
Â  receiveData(data:string):void {
Â  Â  console.log('desde el padre ðŸ”´ðŸ”´ðŸ”´', data)
Â  Â  this.listResults$ = this.searchService.searchTracks$(data) â‡’ Al hacer la peticion de esa manera debemos declarar en el HTML como ASYNC
Â  }
```

Para que la peticion se tome como la mas reciente

```html
<app-play-list-body [tracks]="listResults$ | async"></app-play-list-body>
```